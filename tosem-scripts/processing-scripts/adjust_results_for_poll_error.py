import json
import argparse
import logging
import os

POLL = None
FORCE = False

def parse_args():
    parser = argparse.ArgumentParser(description=(
        "Adjusts for off-by-POLL error in files created by exp2json before Magma poll error was fixed. "
        "This OVERWRITES the provided json file. "
        "See https://github.com/HexHive/magma/pull/179/ for more details."
    ))
    parser.add_argument("jsonfile",
                        help="The file to adjust. Overwrites this file.")
    parser.add_argument('-p', "--poll",
                        default=5,
                        type=int,
                        help="The polling interval used; must be an integer.")
    parser.add_argument('-f', '--force', action='count', default=0,
                        help=("Force poll subtraction even if it looks like it has already been done.")
                        )
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help=("Controls the verbosity of messages. "
                              "-v prints info. -vv prints debug. Default: warnings and higher.")
                        )
    return parser.parse_args()

def configure_verbosity(level):
    mapping = {
        0: logging.WARNING,
        1: logging.INFO,
        2: logging.DEBUG
    }
    # will raise exception when level is invalid
    numeric_level = mapping[level]
    logging.basicConfig(level=numeric_level)

def check_for_force(force_count):
    global FORCE
    if force_count > 0:
        FORCE = True

def set_poll(poll):
    global POLL
    POLL = poll

def check_if_poll_and_update(value, name):
    """
    Checks whether value == POLL. If force not true, this suggests
    the file does not need checking
    :param value: an integer representing bug/reaching triggering time
    :param name: name of the value
    :return: updated poll value, or exits
    """
    if value == POLL and not FORCE:
        logging.warning(f"Found value {value}, at: {name}.\n"
                        f"This suggests off-by-POLL adjustment has already happened, or the file does not have "
                        f"off-by-POLL error to start with. Exiting. To update anyway, use arg -f to force.")
        exit(1)
    return round(value - POLL, 1)

def add_to_dict_path(d, path, value):
    """
    Adds value to d at nested dictionary path path
    :param d: dictionary to add
    :param path: list of dictionary keys
    :param value: integer
    :return: updates in place, no return
    >>> nested_dict = {}
    >>> add_to_dict_path(nested_dict, ['a', 'b'], value=1)
    >>> nested_dict
    {'a': {'b': 1}}
    >>> add_to_dict_path(nested_dict, ['a', 'b'], 2)
    >>> nested_dict
    {'a': {'b': 2}}
    >>> nested_dict = {'results': {}}
    >>> add_to_dict_path(nested_dict, ['results', 'my_fuzzer', 'png', 'png_fuzz', '0', 'reached', 'PNG001'] , 5)
    >>> nested_dict
    {'results': {'my_fuzzer': {'png': {'png_fuzz': {'0': {'reached': {'PNG001': 5}}}}}}}
    >>> add_to_dict_path(nested_dict, ['results', 'my_fuzzer', 'png', 'png_fuzz', '0', 'triggered', 'PNG001'] , 10)
    >>> nested_dict
    {'results': {'my_fuzzer': {'png': {'png_fuzz': {'0': {'reached': {'PNG001': 5}, 'triggered': {'PNG001': 10}}}}}}}
    >>> add_to_dict_path(nested_dict, ['results', 'my_fuzzer', 'png', 'png_fuzz', '0', 'reached', 'PNG002'] , 15)
    >>> nested_dict
    {'results': {'my_fuzzer': {'png': {'png_fuzz': {'0': {'reached': {'PNG001': 5, 'PNG002': 15}, 'triggered': {'PNG001': 10}}}}}}}
    """
    if len(path) == 0:
        return
    key = path[0]
    if len(path) == 1:
        d[key] = value
    else:
        if key not in d:
            d[key] = {}
        add_to_dict_path(d[key], path[1:], value)

def subtract_poll_from_results(json_filename):
    """
    Subtracts POLL from the all the reaching/triggering times in json_filename.
    :param json_filename: file generated by exp2json
    :return: nothing, modifies json_filename
    """
    if not os.path.exists(json_filename):
        logging.WARNING(f"{json_filename} doesn't exist, exiting.")
        exit(1)
    json_file = open(json_filename, "r")
    data = json.load(json_file)
    json_file.close()

    if 'results' not in data:
        logging.WARNING(f"{json_filename} doesn't have 'results' key, exiting.")
        exit(1)

    results = data['results']
    out_data = {'results': {}}
    for fuzzer in results:
        for benchmark in results[fuzzer]:
            for target in results[fuzzer][benchmark]:
                for iteration in results[fuzzer][benchmark][target]:
                     for r_t in results[fuzzer][benchmark][target][iteration]:
                        for bugname in results[fuzzer][benchmark][target][iteration][r_t]:
                            name = f"{fuzzer} on {benchmark}-{target}, iteration {iteration}, {r_t} bug {bugname}"
                            value = results[fuzzer][benchmark][target][iteration][r_t][bugname]
                            new_val = check_if_poll_and_update(value, name)
                            add_to_dict_path(out_data, ['results', fuzzer, benchmark, target, iteration, r_t, bugname], new_val)


    json_file = open(json_filename, "w")
    json.dump(out_data, json_file)
    json_file.close()




def main():
    args = parse_args()
    configure_verbosity(args.verbose)
    check_for_force(args.force)
    set_poll(args.poll)
    logging.info(f"Subtracting {POLL}s from results in {args.jsonfile}, {'with' if FORCE else 'without'} forcing. ")
    subtract_poll_from_results(args.jsonfile)
    logging.info("Done.")

if __name__ == '__main__':
    main()