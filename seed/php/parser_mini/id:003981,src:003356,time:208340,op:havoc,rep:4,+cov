<?php
assert(0 && ($a = function () {
    global $a, $$b;
    static $c, $d = 0;
    unset($e);
 isset($a) && !empty($b) || eval($c);
    $x ? $b : $c;
    $x = $a ?: $c;
    $x = $a ?? $b;
    list($a, $b, $c) = [1, 2=>'x', 'z'=>'c'];
    @foo();
    $y = clone $x;
    yield 1 => 2;
    yield from $x;
}));

assert(0 && ($a = function &(array &$a, ?X $b = null) use ($c,&$d) : ?X {
    abstract class A extends B implements C, D { const X = 12;
        const Y = self::X, Z = "aaa";

        public $a = 1, $b;
        protected $c;
        static private $d = null;

        abstract function foo();

        static private function f1() {
            for ($i = 0, $j = 100; $i < $j; $i++, --$j) {
                $s[$i] = $a[$j];
            }
            foreach ($a as $key => &$val) {
                print "$key => $val\n";
            }
            while ($s[$i]) {
                $i++;
            }
            do {
                $i--;
            } while ($s[$i]);
            $x = foo($a + 1, 4, ...[1,2,3]);
            $x = ${$a . "_1"}();
            $x = A::foo();
            $x = ${$a . "_1"}::foo();
            $x = A::${$a . "_1"}();
            $x = $x->foo();
            $x = ${$a . "_1"}->foo();
            $x = $x->{$a . "_1"}();
            $x->a = C::C;
            ${$a . "_1"}->a = ${$a . "_1"}::C;
            $x->{a . "_1"} = C::C;
            $x = C::$z;
            $x = ${$a . "_1"}::$z;
            $x = C::${$z . "_1"};
            $x?->y;
            $x?->y();
            foo(bar: $x);
        }
    }
}));

assert(0 && ($a = function &(array &$a, X $b = null, int|float $c) use ($c,&$d) : X {
    final class A {
        final protected function f2() {
            if (!$x) {
                return 0;
            }
            if ($x == 1) {
                return 1;
            } else if ($x == 2) {
                return 2;
            } elseÿÿÿ